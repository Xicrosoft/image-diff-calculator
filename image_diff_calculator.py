#!/usr/bin/env python3

"""
Image Difference Ratio Calculator
Calculate the difference ratio between two images using various algorithms

This code was generated by GitHub Copilot Agent mode using Claude Sonnet 4
For testing purposes only. Please review the code before using it in production.
"""

import argparse
import os
import sys
from typing import Tuple

import cv2
import matplotlib.pyplot as plt
import numpy as np


class ImageDiffCalculator:
    """Image difference calculator class"""

    def __init__(self):
        self.supported_methods = [
            'mse',  # Mean Squared Error
            'ssim',  # Structural Similarity Index
            'histogram',  # Histogram Comparison
            'pixel_diff',  # Pixel Difference
            'hash',  # Perceptual Hash
        ]

    def load_images(self, image1_path: str, image2_path: str) -> Tuple[np.ndarray, np.ndarray]:
        """
        Load two images
        
        Args:
            image1_path: Path to the first image
            image2_path: Path to the second image
            
        Returns:
            tuple: Two image numpy arrays
        """
        if not os.path.exists(image1_path):
            raise FileNotFoundError(f"Image file does not exist: {image1_path}")
        if not os.path.exists(image2_path):
            raise FileNotFoundError(f"Image file does not exist: {image2_path}")

        img1 = cv2.imread(image1_path)
        img2 = cv2.imread(image2_path)

        if img1 is None:
            raise ValueError(f"Cannot read image: {image1_path}")
        if img2 is None:
            raise ValueError(f"Cannot read image: {image2_path}")

        return img1, img2

    def resize_images(self, img1: np.ndarray, img2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Resize two images to the same dimensions
        
        Args:
            img1: First image
            img2: Second image
            
        Returns:
            tuple: Two resized images
        """
        h1, w1 = img1.shape[:2]
        h2, w2 = img2.shape[:2]

        # Use the smaller dimensions as target size
        target_h = min(h1, h2)
        target_w = min(w1, w2)

        img1_resized = cv2.resize(img1, (target_w, target_h))
        img2_resized = cv2.resize(img2, (target_w, target_h))

        return img1_resized, img2_resized

    def calculate_mse(self, img1: np.ndarray, img2: np.ndarray) -> float:
        """
        Calculate Mean Squared Error (MSE)
        
        Args:
            img1: First image
            img2: Second image
            
        Returns:
            float: MSE value, smaller value indicates more similar images
        """
        mse = np.mean((img1.astype("float") - img2.astype("float")) ** 2)
        return float(mse)

    def calculate_ssim(self, img1: np.ndarray, img2: np.ndarray) -> float:
        """
        Calculate Structural Similarity Index (SSIM)
        
        Args:
            img1: First image
            img2: Second image
            
        Returns:
            float: SSIM value, range [0,1], larger value indicates more similar images
        """
        # Convert to grayscale
        gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
        gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

        # SSIM calculation parameters
        c1 = (0.01 * 255) ** 2
        c2 = (0.03 * 255) ** 2

        # Calculate means
        mu1 = cv2.GaussianBlur(gray1.astype(np.float64), (11, 11), 1.5)
        mu2 = cv2.GaussianBlur(gray2.astype(np.float64), (11, 11), 1.5)

        mu1_sq = mu1 * mu1
        mu2_sq = mu2 * mu2
        mu1_mu2 = mu1 * mu2

        # Calculate variances and covariance
        sigma1_sq = cv2.GaussianBlur(gray1.astype(np.float64) *
                                     gray1.astype(np.float64), (11, 11), 1.5) - mu1_sq
        sigma2_sq = cv2.GaussianBlur(gray2.astype(np.float64) *
                                     gray2.astype(np.float64), (11, 11), 1.5) - mu2_sq
        sigma12 = cv2.GaussianBlur(gray1.astype(np.float64) *
                                   gray2.astype(np.float64), (11, 11), 1.5) - mu1_mu2

        # Calculate SSIM
        ssim_map = (((2 * mu1_mu2 + c1) * (2 * sigma12 + c2)) /
                    ((mu1_sq + mu2_sq + c1) * (sigma1_sq + sigma2_sq + c2)))

        return float(np.mean(ssim_map))

    def calculate_histogram_diff(self, img1: np.ndarray, img2: np.ndarray) -> float:
        """
        Calculate histogram difference
        
        Args:
            img1: First image
            img2: Second image
            
        Returns:
            float: Histogram correlation, range [0,1], larger value indicates more similar images
        """
        # Calculate histogram for each channel
        hist1_b = cv2.calcHist([img1], [0], None, [256], [0, 256])
        hist1_g = cv2.calcHist([img1], [1], None, [256], [0, 256])
        hist1_r = cv2.calcHist([img1], [2], None, [256], [0, 256])

        hist2_b = cv2.calcHist([img2], [0], None, [256], [0, 256])
        hist2_g = cv2.calcHist([img2], [1], None, [256], [0, 256])
        hist2_r = cv2.calcHist([img2], [2], None, [256], [0, 256])

        # Calculate correlation
        corr_b = cv2.compareHist(hist1_b, hist2_b, cv2.HISTCMP_CORREL)
        corr_g = cv2.compareHist(hist1_g, hist2_g, cv2.HISTCMP_CORREL)
        corr_r = cv2.compareHist(hist1_r, hist2_r, cv2.HISTCMP_CORREL)

        return (corr_b + corr_g + corr_r) / 3.0

    def calculate_pixel_diff_ratio(self,
                                   img1: np.ndarray,
                                   img2: np.ndarray,
                                   threshold: int = 30) -> float:
        """
        Calculate pixel difference ratio
        
        Args:
            img1: First image
            img2: Second image
            threshold: Pixel difference threshold
            
        Returns:
            float: Different pixel ratio, range [0,1], smaller value indicates more similar images
        """
        # Calculate absolute difference
        diff = cv2.absdiff(img1, img2)
        # Convert to grayscale
        gray_diff = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
        # Count pixels above threshold
        diff_pixels = np.sum(gray_diff > threshold)
        total_pixels = gray_diff.shape[0] * gray_diff.shape[1]

        return diff_pixels / total_pixels

    def calculate_perceptual_hash_diff(self, img1: np.ndarray, img2: np.ndarray) -> float:
        """
        Calculate perceptual hash difference
        
        Args:
            img1: First image
            img2: Second image
            
        Returns:
            float: Hamming distance, smaller value indicates more similar images
        """
        # Convert to grayscale and resize
        gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
        gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

        resized1 = cv2.resize(gray1, (8, 8))
        resized2 = cv2.resize(gray2, (8, 8))

        # Calculate average values
        avg1 = np.mean(resized1)
        avg2 = np.mean(resized2)

        # Generate hashes
        hash1 = resized1 > avg1
        hash2 = resized2 > avg2

        # Calculate Hamming distance
        hamming_distance = np.sum(hash1 != hash2)

        return hamming_distance / 64.0  # Normalize to [0,1]

    def calculate_diff_ratio(self, image1_path: str, image2_path: str, method: str = 'mse') -> dict:
        """
        Calculate difference ratio between two images
        
        Args:
            image1_path: Path to the first image
            image2_path: Path to the second image
            method: Calculation method
            
        Returns:
            dict: Dictionary containing difference ratio and related information
        """
        if method not in self.supported_methods:
            raise ValueError(
                f"Unsupported method: {method}. Supported methods: {self.supported_methods}")

        # Load images
        img1, img2 = self.load_images(image1_path, image2_path)

        # Resize images
        img1, img2 = self.resize_images(img1, img2)

        result = {
            'image1_path': image1_path,
            'image2_path': image2_path,
            'method': method,
            'image_size': img1.shape
        }

        if method == 'mse':
            diff_value = self.calculate_mse(img1, img2)
            result['mse'] = diff_value
            result['similarity_ratio'] = 1.0 / (1.0 + diff_value / 1000.0)  # Normalized similarity

        elif method == 'ssim':
            ssim_value = self.calculate_ssim(img1, img2)
            result['ssim'] = ssim_value
            result['similarity_ratio'] = ssim_value

        elif method == 'histogram':
            hist_corr = self.calculate_histogram_diff(img1, img2)
            result['histogram_correlation'] = hist_corr
            result['similarity_ratio'] = hist_corr

        elif method == 'pixel_diff':
            diff_ratio = self.calculate_pixel_diff_ratio(img1, img2)
            result['pixel_diff_ratio'] = diff_ratio
            result['similarity_ratio'] = 1.0 - diff_ratio

        elif method == 'hash':
            hash_diff = self.calculate_perceptual_hash_diff(img1, img2)
            result['hash_distance'] = hash_diff
            result['similarity_ratio'] = 1.0 - hash_diff

        return result

    def save_diff_visualization(self,
                                image1_path: str,
                                image2_path: str,
                                output_path: str = 'diff_visualization.png'):
        """
        Save image difference visualization results
        
        Args:
            image1_path: Path to the first image
            image2_path: Path to the second image
            output_path: Output path
        """
        img1, img2 = self.load_images(image1_path, image2_path)
        img1, img2 = self.resize_images(img1, img2)

        # Calculate difference image
        diff = cv2.absdiff(img1, img2)

        # Create visualization
        plt.figure(figsize=(15, 5))

        plt.subplot(1, 4, 1)
        plt.imshow(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB))
        plt.title('Image 1')
        plt.axis('off')

        plt.subplot(1, 4, 2)
        plt.imshow(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB))
        plt.title('Image 2')
        plt.axis('off')

        plt.subplot(1, 4, 3)
        plt.imshow(cv2.cvtColor(diff, cv2.COLOR_BGR2RGB))
        plt.title('Difference')
        plt.axis('off')

        plt.subplot(1, 4, 4)
        # Calculate results for all methods
        results = {}
        for method in self.supported_methods:
            try:
                result = self.calculate_diff_ratio(image1_path, image2_path, method)
                results[method] = result['similarity_ratio']
            except:
                continue

        methods = list(results.keys())
        similarities = list(results.values())

        plt.bar(methods, similarities)
        plt.title('Similarity Comparison')
        plt.ylabel('Similarity')
        plt.xticks(rotation=45)
        plt.ylim(0, 1)

        plt.tight_layout()
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        plt.close()

        print(f"Difference visualization saved to: {output_path}")


def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='Calculate difference ratio between two images')
    parser.add_argument('image1',
                        help='Path to the first image')
    parser.add_argument('image2',
                        help='Path to the second image')
    parser.add_argument('--method', '-m',
                        choices=['mse', 'ssim', 'histogram', 'pixel_diff', 'hash', 'all'],
                        default='mse',
                        help='Calculation method (default: mse)')
    parser.add_argument('--visualize', '-v',
                        action='store_true',
                        help='Generate difference visualization')
    parser.add_argument('--output', '-o',
                        default='diff_visualization.png',
                        help='Visualization output path')

    args = parser.parse_args()

    calculator = ImageDiffCalculator()

    try:
        if args.method == 'all':
            print("Calculating image differences using all methods:")
            print("=" * 50)

            for method in calculator.supported_methods:
                try:
                    result = calculator.calculate_diff_ratio(args.image1, args.image2, method)
                    print(f"\nMethod: {method.upper()}")
                    print(f"Similarity: {result['similarity_ratio']:.4f}")

                    if method == 'mse':
                        print(f"MSE value: {result['mse']:.2f}")
                    elif method == 'ssim':
                        print(f"SSIM value: {result['ssim']:.4f}")
                    elif method == 'histogram':
                        print(f"Histogram correlation: {result['histogram_correlation']:.4f}")
                    elif method == 'pixel_diff':
                        print(f"Pixel difference ratio: {result['pixel_diff_ratio']:.4f}")
                    elif method == 'hash':
                        print(f"Hash distance: {result['hash_distance']:.4f}")

                except Exception as e:
                    print(f"Method {method} calculation failed: {e}")
        else:
            result = calculator.calculate_diff_ratio(args.image1, args.image2, args.method)
            print("Image difference calculation results:")
            print(f"Method: {result['method'].upper()}")
            print(f"Similarity: {result['similarity_ratio']:.4f}")

            # Print detailed information
            for key, value in result.items():
                if key not in ['image1_path', 'image2_path',
                               'method', 'image_size', 'similarity_ratio']:
                    print(f"{key}: {value:.4f}")

        if args.visualize:
            calculator.save_diff_visualization(args.image1, args.image2, args.output)

    except Exception as e:
        print(f"Error: {e}")
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
